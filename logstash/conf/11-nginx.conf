filter 
{
    if [type] == "nginx-access" {

        grok {
            patterns_dir => "/etc/logstash/patterns"
            match => [ "message", "%{NGINXACCESS}" ]
        }

        date {
            match => [ "time" , "dd/MMM/YYYY:HH:mm:ss Z" ]
        }
    }
    if [type] == "nginx-error" {
        grok {
            match =>{"message" =>
                [
                "(?<timestamp>\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}) \[%{DATA:err_severity}\] (%{NUMBER:pid:int}#%{NUMBER}: \*%{NUMBER}|\*%{NUMBER}) %{DATA:err_message}(?:, client: (?<client_ip>%{IP}|%{HOSTNAME}))(?:, server: %{IPORHOST:server})(?:, request: %{QS:request})?(?:, host: %{QS:client_ip})?(?:, referrer: \"%{URI:referrer})?",
                "%{DATESTAMP:timestamp} \[%{DATA:err_severity}\] %{GREEDYDATA:err_message}"
                ]
            }
        }
    }
}
filter
{
    grok {
        match => { "message" => "(?<datetime>\d\d\d\d/\d\d/\d\d \d\d:\d\d:\d\d) \[(?<errtype>\w+)\] \S+: \*\d+ (?<errmsg>[^,]+), (?<errinfo>.*)$" }
    }
    mutate {
        rename => [ "host", "fromhost" ]
            gsub => [ "errmsg", "too large body: \d+ bytes", "too large body" ]
    }
    if [errinfo]
    {
        ruby {
            code => "event.append(Hash[event['errinfo'].split(', ').map{|l| l.split(': ')}])"
        }
    }
    grok {
        match => { "request" => '"%{WORD:verb} %{URIPATH:urlpath}(?:\?%{URIPATHPARAM:urlparam})?(?: HTTP/%{NUMBER:httpversion})"' }
        patterns_dir => "/etc/logstash/patterns"
            remove_field => [ "message", "errinfo", "request" ]
    }
}
